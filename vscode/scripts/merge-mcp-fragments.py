#!/usr/bin/env python3
"""Merge per-profile MCP manifests into a Codex-friendly TOML fragment.

Usage:
    python scripts/merge-mcp-fragments.py <slug1> [<slug2> ...]

Behaviour (summary):
 - Loads packs/*/mcp/servers.<slug>.json for each requested slug.
 - Validates minimal structure, deduplicates servers by id.
 - Emits codex-mcp.generated.toml at workspace root (atomic write via .tmp).
 - Warns on conflicts (same id, different TOML fragments) and records comments.
"""

from __future__ import annotations

import json
import sys
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, List, Optional, Tuple


ROOT = Path(__file__).resolve().parents[1]
OUTPUT_FILE = ROOT / "codex-mcp.generated.toml"
OUTPUT_TMP = OUTPUT_FILE.with_suffix(".tmp")


@dataclass
class ServerEntry:
    id: str
    human_name: str
    category: str
    source: Dict
    config_toml: str
    profiles: List[str] = field(default_factory=list)
    optional: bool = False
    experimental: bool = False
    privacy_sensitive: bool = False
    recommended_read_only: bool = False
    conflict_note: Optional[str] = None


def usage() -> None:
    msg = "Usage: python scripts/merge-mcp-fragments.py <slug1> <slug2> ..."
    print(msg, file=sys.stderr)


def find_manifest(slug: str) -> Optional[Path]:
    matches = sorted(ROOT.glob(f"packs/*/mcp/servers.{slug}.json"))
    if not matches:
        print(f"[ERROR] No manifest found for slug '{slug}'. Expected packs/*/mcp/servers.{slug}.json", file=sys.stderr)
        return None
    if len(matches) > 1:
        print(f"[ERROR] Multiple manifests found for slug '{slug}', refusing to guess:", file=sys.stderr)
        for m in matches:
            print(f"  - {m}", file=sys.stderr)
        return None
    return matches[0]


def load_manifest(path: Path, slug: str) -> Optional[Dict]:
    try:
        data = json.loads(path.read_text())
    except Exception as exc:  # pragma: no cover - informative error path
        print(f"[ERROR] Failed to parse JSON {path}: {exc}", file=sys.stderr)
        return None

    if data.get("profile_slug") != slug:
        print(f"[ERROR] Manifest {path} profile_slug '{data.get('profile_slug')}' does not match requested '{slug}'", file=sys.stderr)
        return None
    servers = data.get("servers")
    if not isinstance(servers, list):
        print(f"[ERROR] Manifest {path} has no valid 'servers' list", file=sys.stderr)
        return None
    for idx, server in enumerate(servers, start=1):
        sid = server.get("id")
        cfg = server.get("config_fragments", {}).get("codex_config_toml")
        if not sid or not cfg:
            print(f"[ERROR] Manifest {path} server #{idx} missing id or config_fragments.codex_config_toml", file=sys.stderr)
            return None
    data["__path"] = str(path)
    return data


def merge_servers(manifests: List[Dict]) -> Tuple[Dict[str, ServerEntry], List[str]]:
    merged: Dict[str, ServerEntry] = {}
    conflicts: List[str] = []

    for manifest in manifests:
        slug = manifest.get("profile_slug")
        for server in manifest.get("servers", []):
            sid = server["id"]
            cfg = server.get("config_fragments", {}).get("codex_config_toml", "")
            existing = merged.get(sid)
            if existing:
                if existing.config_toml != cfg:
                    note = (
                        f"Conflict for server id '{sid}' across profiles "
                        f"{','.join(sorted(set(existing.profiles + [slug])))}; kept first fragment."
                    )
                    conflicts.append(note)
                    if not existing.conflict_note:
                        existing.conflict_note = note
                if slug not in existing.profiles:
                    existing.profiles.append(slug)
                continue

            entry = ServerEntry(
                id=sid,
                human_name=server.get("human_name", sid),
                category=server.get("category", "general"),
                source=server.get("source", {}),
                config_toml=cfg,
                profiles=[slug],
                optional=bool(server.get("optional")),
                experimental=bool(server.get("experimental")),
                privacy_sensitive=bool(server.get("privacy_sensitive")),
                recommended_read_only=bool(server.get("recommended_read_only")),
            )
            merged[sid] = entry

    return merged, conflicts


def write_toml(slugs: List[str], servers: Dict[str, ServerEntry], conflicts: List[str]) -> int:
    if not servers:
        print("[ERROR] No servers to write; nothing generated.", file=sys.stderr)
        return 1

    lines: List[str] = []
    lines.append("# AUTOGENERATED by scripts/merge-mcp-fragments.py")
    lines.append(f"# Source profiles: {', '.join(slugs)}")
    lines.append("# Review and copy selected blocks into your ~/.codex/config.toml")

    if conflicts:
        lines.append("# Conflicts detected (kept first occurrence):")
        for c in conflicts:
            lines.append(f"# - {c}")

    for sid in sorted(servers.keys()):
        s = servers[sid]
        lines.append("")
        lines.append(f"# MCP server: {s.human_name} (id: {s.id})")
        lines.append(f"# Categories: {s.category}")
        lines.append(f"# From profiles: {', '.join(sorted(s.profiles))}")
        src_type = s.source.get("type", "unknown")
        src_url = s.source.get("url", "")
        lines.append(f"# Source: {src_type} {src_url}")
        lines.append(f"# Optional: {str(s.optional).lower()}")
        lines.append(f"# Experimental: {str(s.experimental).lower()}")
        lines.append(f"# Privacy sensitive: {str(s.privacy_sensitive).lower()}")
        lines.append(f"# Recommended read-only: {str(s.recommended_read_only).lower()}")
        if s.conflict_note:
            lines.append(f"# NOTE: {s.conflict_note}")
        lines.append(s.config_toml.rstrip())

    OUTPUT_TMP.write_text("\n".join(lines) + "\n")
    OUTPUT_TMP.replace(OUTPUT_FILE)
    print(f"[OK] Wrote {OUTPUT_FILE}")
    return 0


def main(argv: List[str] | None = None) -> int:
    args = list(sys.argv[1:] if argv is None else argv)
    if not args:
        usage()
        return 1

    manifests: List[Dict] = []
    for slug in args:
        path = find_manifest(slug)
        if not path:
            continue
        data = load_manifest(path, slug)
        if data:
            manifests.append(data)

    merged, conflicts = merge_servers(manifests)
    rc = write_toml(args, merged, conflicts)
    return rc


if __name__ == "__main__":  # pragma: no cover
    sys.exit(main())
